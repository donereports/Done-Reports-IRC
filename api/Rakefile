def init(env=ENV['RACK_ENV']); end
require File.join('.', 'environment.rb')

namespace :db do
  task :bootstrap do
    init
    DataMapper.auto_migrate!
  end

  task :migrate do
    init
    DataMapper.auto_upgrade!
  end
end

namespace :github do
  # Add the appropriate Github hooks to all repositories on the account
  task :add_hooks do

    Account.all.each do |account|

      account.groups.each do |group|

        response = RestClient.get "https://api.github.com/orgs/#{group.github_organization}/repos", :authorization => "Bearer #{group.github_access_token}"
        repos = JSON.parse response

        repos.each do |repo|
          puts repo["name"]

          # Remove all existing hooks
          json = RestClient.get repo["hooks_url"], :authorization => "Bearer #{group.github_access_token}"
          hooks = JSON.parse json
          hooks.each do |hook|
            puts hook["url"]
            response = RestClient.delete hook["url"], :authorization => "Bearer #{group.github_access_token}"
            puts response
          end

          # Add the new correct hook
          # '{"name":"web","active":true,"events":["commit_comment","create","delete","download","follow","fork","fork_apply","gist","gollum","issue_comment","issues","member","public","pull_request","pull_request_review_comment","push","status","team_add","watch"],"config":{"url":"https://status-report.geoloqi.com/hook/github?token=XXXX","content_type":"json"}}'
          payload = {
            name: "web",
            active: true,
            events: ["commit_comment","create","delete","download","follow","fork","fork_apply","gist","gollum","issue_comment","issues","member","public","pull_request","pull_request_review_comment","push","status","team_add","watch"],
            config: {
              url: "https://status-report.geoloqi.com/hook/github?token=#{group.github_token}",
              content_type: "json"
            }
          }
          response = RestClient.post repo["hooks_url"], payload.to_json, :authorization => "Bearer #{group.github_access_token}"
          puts response
        end

      end #group
    end #account

  end
end

namespace :report do
  task :cron do

    ses = AWS::SES::Base.new(
      :access_key_id     => SiteConfig.aws_key_id,
      :secret_access_key => SiteConfig.aws_secret
    )

    # This is a cron task that runs every 5 minutes.

    # Send out any reminders for deadlines coming soon.
    # Send out emails for any reports that are open and past the deadline.

    Account.all.each do |account|
      puts "Processing account '#{account.name}'"

      account.groups.each do |group|

        # Create the object that will be passed into the email erb template
        email_data = {
          :group => nil,
          :report => nil,
          :report_localtime => nil,
          :users => []
        }

        puts "  Group '#{group.name}'"
        email_data[:group] = group

        # Find an open report, if there are none, then this will create one
        report = Report.current_report(group)
        puts "    Report ##{report.id}"
        email_data[:report] = report

        zone = Timezone::Zone.new :zone => group.due_timezone

        # If the current time is past the due date, close the report and send an email summary
        if DateTime.now > report.date_due
          report.date_completed = DateTime.now
          email_data[:report_localtime] = report.date_completed.to_time.localtime(zone.utc_offset)
          report.save

          # Each user gets their own section
          account.users.each do |user|
            # Only include this user in the email if they have some entries
            if report.entries.all(:user => user).count > 0

              puts "      #{user.username}"
              num_entries = 0

              # Gather all the entries for this report, grouped by type
              types = [
                {:type => 'past',     :title => 'What did you do?', :entries => []},
                {:type => 'future',   :title => 'What is your plan for tomorrow?', :entries => []},
                {:type => 'blocking', :title => 'What is blocking you?', :entries => []},
                {:type => 'hero',     :title => 'Who is your hero?', :entries => []},
                {:type => 'unknown',  :title => 'Other Updates', :entries => []},
              ]
              types.each do |type|
                entries = report.entries.all(:type => type[:type], :user => user)
                if entries.count > 0 
                  puts "        #{type[:title]}"
                  entries.each do |entry| 
                    puts "          * #{entry.message}"
                    num_entries += 1
                    type[:entries] << entry
                  end
                end
              end

              # Find any repos this user committed to during the report period
              repos = Repo.all(:commits => Commit.all(:user => user, 
                :date.gt => report.date_started, 
                :date.lt => report.date_completed))

              if repos.count > 0
                type = {
                  :type => 'commits', :title => 'Active Projects', :entries => []
                }
                puts "        Commits"
                repos.each do |r|
                  puts "          * #{r.name}"
                  type[:entries] << r
                end
                types << type
              end

              if num_entries > 0
                email_data[:users] << {
                  :user => user,
                  :types => types
                }
              end

            end
          end

          if email_data[:users].count > 0

            # Merge the data with the email template in email.erb
            puts "------"
            template = Erubis::Eruby.new File.read 'views/email.erb'
            email_html = template.result email_data
            puts email_html

            template_text = Erubis::Eruby.new File.read 'views/email_text.erb'
            email_text = template_text.result email_data
            puts email_text
            puts "------"

            # Send the email via Amazon SES now
            ses.send_email :to => group.email_recipient.split(","),
              :source => 'done@geoloqi.com',
              :subject => 'Report',
              :text_body => email_text,
              :html_body => email_html

          end

        # If the current time is past the reminder time, send out reminder emails
        elsif report.date_reminder != nil && DateTime.now > report.date_reminder
          report.date_reminder_sent = DateTime.now
          report.save



        else
          puts "      In progress"
        end

      end # end group
    end # end account

  end

  task :test do
    account = Account.first :id => 1
    group = Group.first :id => 1

    report = Report.current_report(group)

    #puts report.inspect
  end
end

